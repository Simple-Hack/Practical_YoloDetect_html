<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>&#x9a7e;&#x9a76;&#x884c;&#x4e3a;&#x68c0;&#x6d4b;&#x7cfb;&#x7edf;&#x6280;&#x672f;&#x5b9e;&#x73b0;&#x8bf4;&#x660e;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="驾驶行为检测系统技术实现说明">驾驶行为检测系统技术实现说明</h1>
<h2 id="系统概述">系统概述</h2>
<p>该系统是一个基于深度学习的驾驶行为检测系统，能够检测图片和视频中的驾驶行为，如安全驾驶、疲劳驾驶、分心驾驶、玩手机等。系统采用前后端分离架构，前端使用纯HTML/CSS/JavaScript实现，后端使用Python的Flask框架构建REST API服务。</p>
<h2 id="技术架构">技术架构</h2>
<h3 id="前端技术栈">前端技术栈</h3>
<ul>
<li>HTML5 + CSS3 + JavaScript</li>
<li>Chart.js：用于数据可视化</li>
<li>Font Awesome：提供图标支持</li>
</ul>
<h3 id="后端技术栈">后端技术栈</h3>
<ul>
<li>Python 3.x</li>
<li>Flask：Web框架</li>
<li>Flask-CORS：处理跨域请求</li>
<li>Ultralytics YOLO：对象检测模型</li>
<li>OpenCV (cv2)：图像和视频处理</li>
<li>PIL (Pillow)：图像处理</li>
<li>FFmpeg：视频格式转换（可选）</li>
</ul>
<h2 id="数据流程">数据流程</h2>
<p>整个系统的数据流程如下：</p>
<ol>
<li>用户在前端上传图片或视频</li>
<li>前端将文件通过HTTP请求发送到后端API</li>
<li>后端接收文件并保存到临时目录</li>
<li>后端加载YOLO模型并对图片/视频进行处理</li>
<li>后端将处理结果返回给前端</li>
<li>前端展示检测结果、统计信息和可视化图表</li>
</ol>
<h2 id="关键技术实现">关键技术实现</h2>
<h3 id="1-文件上传与传输">1. 文件上传与传输</h3>
<h4 id="前端实现">前端实现</h4>
<p>前端通过<code>FormData</code>对象封装上传的文件，并使用<code>fetch</code> API发送到后端：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();
formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, selectedFile);

<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`<span class="hljs-subst">${API_BASE_URL}</span><span class="hljs-subst">${endpoint}</span>`</span>, {
    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
    <span class="hljs-attr">body</span>: formData
});
</code></pre>
<h4 id="后端实现">后端实现</h4>
<p>后端使用Flask的<code>request.files</code>接收上传的文件：</p>
<pre><code class="language-python">file = request.files[<span class="hljs-string">&#x27;file&#x27;</span>]
file_id = <span class="hljs-built_in">str</span>(uuid.uuid4())  <span class="hljs-comment"># 生成唯一ID</span>
input_path = os.path.join(UPLOAD_FOLDER, <span class="hljs-string">f&quot;<span class="hljs-subst">{file_id}</span>.jpg/mp4&quot;</span>)
file.save(input_path)  <span class="hljs-comment"># 保存文件</span>
</code></pre>
<h3 id="2-图像处理与目标检测">2. 图像处理与目标检测</h3>
<h4 id="模型加载">模型加载</h4>
<p>系统使用Ultralytics YOLO模型进行目标检测：</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_model</span>():
    <span class="hljs-keyword">global</span> model_car_inside_detection
    <span class="hljs-keyword">try</span>:
        model_car_inside_detection = YOLO(<span class="hljs-string">r&#x27;.\models\car_inside_detect.pt&#x27;</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;模型加载失败: <span class="hljs-subst">{e}</span>&quot;</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
</code></pre>
<h4 id="图像处理流程">图像处理流程</h4>
<ol>
<li>加载保存的图像</li>
<li>使用YOLO模型进行预测</li>
<li>将预测结果绘制到原图上</li>
<li>提取检测到的对象信息、置信度等</li>
<li>将标注后的图像保存并返回URL</li>
</ol>
<pre><code class="language-python"><span class="hljs-comment"># 使用模型进行预测</span>
results = model(input_path, conf=<span class="hljs-number">0.25</span>, iou=<span class="hljs-number">0.45</span>)

<span class="hljs-comment"># 保存标注后的图片</span>
<span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:
    im_array = r.plot()  <span class="hljs-comment"># 获取绘制后的图像数组</span>
    im = Image.fromarray(im_array[..., ::-<span class="hljs-number">1</span>])  <span class="hljs-comment"># RGB to BGR</span>
    im.save(output_path)
</code></pre>
<h3 id="3-视频处理技术">3. 视频处理技术</h3>
<p>视频处理是系统的核心难点，主要涉及以下技术：</p>
<h4 id="视频帧提取与处理">视频帧提取与处理</h4>
<p>使用OpenCV逐帧读取视频并处理：</p>
<pre><code class="language-python">cap = cv2.VideoCapture(input_path)
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    ret, frame = cap.read()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ret:
        <span class="hljs-keyword">break</span>
    
    <span class="hljs-comment"># 保存当前帧为临时图像</span>
    temp_frame_path = os.path.join(temp_dir, <span class="hljs-string">f&quot;frame_<span class="hljs-subst">{frame_count}</span>.jpg&quot;</span>)
    cv2.imwrite(temp_frame_path, frame)
    
    <span class="hljs-comment"># 使用YOLO模型进行预测</span>
    results = model(temp_frame_path, conf=<span class="hljs-number">0.25</span>, iou=<span class="hljs-number">0.45</span>)
    
    <span class="hljs-comment"># 处理检测结果</span>
    <span class="hljs-comment"># ...</span>
</code></pre>
<h4 id="连续行为分析">连续行为分析</h4>
<p>系统实现了对驾驶行为的连续跟踪和分析：</p>
<pre><code class="language-python"><span class="hljs-comment"># 检查是否连续检测到相同类别</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(class_history) == consecutive_threshold:
    <span class="hljs-comment"># 检查是否所有元素都相同</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(cls == class_history[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> class_history) <span class="hljs-keyword">and</span> class_history[<span class="hljs-number">0</span>] != <span class="hljs-string">&quot;未知&quot;</span>:
        current_confirmed_class = class_history[<span class="hljs-number">0</span>]
</code></pre>
<h4 id="视频生成">视频生成</h4>
<p>处理完所有帧后，使用OpenCV的VideoWriter将结果合成为新视频：</p>
<pre><code class="language-python"><span class="hljs-comment"># 创建视频写入器</span>
fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">&#x27;avc1&#x27;</span>)
out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

<span class="hljs-comment"># 写入处理后的帧</span>
out.write(annotated_frame)
</code></pre>
<h4 id="视频格式转换">视频格式转换</h4>
<p>为提高浏览器兼容性，系统支持使用FFmpeg将视频转换为WebM格式：</p>
<pre><code class="language-python">command = [
    ffmpeg_cmd, <span class="hljs-string">&#x27;-i&#x27;</span>, input_abs_path, 
    <span class="hljs-string">&#x27;-c:v&#x27;</span>, <span class="hljs-string">&#x27;libvpx-vp9&#x27;</span>, <span class="hljs-string">&#x27;-crf&#x27;</span>, <span class="hljs-string">&#x27;30&#x27;</span>, <span class="hljs-string">&#x27;-b:v&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>,
    output_abs_path
]
result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=<span class="hljs-literal">True</span>)
</code></pre>
<h3 id="4-实时进度反馈">4. 实时进度反馈</h3>
<p>系统实现了视频处理进度的实时反馈机制：</p>
<h4 id="后端实现-1">后端实现</h4>
<p>后端维护一个全局字典存储处理进度：</p>
<pre><code class="language-python">processing_progress = {}

<span class="hljs-comment"># 更新处理进度</span>
current_progress = frame_count / total_frames
processing_progress[file_name] = current_progress
</code></pre>
<h4 id="前端实现-1">前端实现</h4>
<p>前端定期轮询后端获取进度：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">startProgressCheck</span>(<span class="hljs-params">fileName</span>) {
    progressCheckInterval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">async</span> () =&gt; {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`<span class="hljs-subst">${API_BASE_URL}</span>/progress?filename=<span class="hljs-subst">${<span class="hljs-built_in">encodeURIComponent</span>(fileName)}</span>`</span>);
        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
        
        <span class="hljs-keyword">if</span> (data.<span class="hljs-property">progress</span> !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-keyword">const</span> progressPercent = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(data.<span class="hljs-property">progress</span> * <span class="hljs-number">100</span>);
            progressBarProcessing.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">`<span class="hljs-subst">${progressPercent}</span>%`</span>;
            progressBarProcessing.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-progress&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">${progressPercent}</span>%`</span>);
        }
    }, <span class="hljs-number">1000</span>);
}
</code></pre>
<h3 id="5-结果展示与可视化">5. 结果展示与可视化</h3>
<h4 id="统计信息分析">统计信息分析</h4>
<p>系统会分析检测结果并生成统计信息：</p>
<pre><code class="language-python"><span class="hljs-comment"># 计算各类别统计信息</span>
cls_stat = class_stats[mapped_cls_name]
cls_stat[<span class="hljs-string">&#x27;count&#x27;</span>] += <span class="hljs-number">1</span>
cls_stat[<span class="hljs-string">&#x27;conf_sum&#x27;</span>] += conf
cls_stat[<span class="hljs-string">&#x27;max_conf&#x27;</span>] = <span class="hljs-built_in">max</span>(cls_stat[<span class="hljs-string">&#x27;max_conf&#x27;</span>], conf)
cls_stat[<span class="hljs-string">&#x27;min_conf&#x27;</span>] = <span class="hljs-built_in">min</span>(cls_stat[<span class="hljs-string">&#x27;min_conf&#x27;</span>], conf)
</code></pre>
<h4 id="数据可视化">数据可视化</h4>
<p>前端使用Chart.js创建交互式图表：</p>
<pre><code class="language-javascript">categoryCountChart = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chart</span>(countCtx, {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,
    <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">labels</span>: labels,
        <span class="hljs-attr">datasets</span>: [{
            <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;检测数量&#x27;</span>,
            <span class="hljs-attr">data</span>: counts,
            <span class="hljs-attr">backgroundColor</span>: primaryColor,
            <span class="hljs-attr">borderColor</span>: primaryColor,
            <span class="hljs-attr">borderWidth</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">4</span>
        }]
    },
    <span class="hljs-comment">// 配置选项...</span>
});
</code></pre>
<h2 id="关键算法">关键算法</h2>
<h3 id="行为连续检测算法">行为连续检测算法</h3>
<p>系统采用滑动窗口方法检测持续的驾驶行为：</p>
<ol>
<li>维护一个固定长度的类别历史记录队列</li>
<li>每处理一帧，将当前帧检测到的最可能类别加入队列</li>
<li>如果队列已满，移除最早的记录</li>
<li>检查队列中是否所有元素都是相同类别</li>
<li>如果是，则确认当前行为类别</li>
</ol>
<pre><code class="language-python">class_history.append(main_class)
<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(class_history) &gt; consecutive_threshold:
    class_history.pop(<span class="hljs-number">0</span>)

<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(class_history) == consecutive_threshold:
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">all</span>(cls == class_history[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> class_history) <span class="hljs-keyword">and</span> class_history[<span class="hljs-number">0</span>] != <span class="hljs-string">&quot;未知&quot;</span>:
        current_confirmed_class = class_history[<span class="hljs-number">0</span>]
</code></pre>
<h3 id="类别映射算法">类别映射算法</h3>
<p>系统实现了类别映射，将相似的检测类别合并：</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">map_class_name</span>(<span class="hljs-params">cls_name</span>):
    <span class="hljs-string">&quot;&quot;&quot;
    合并特定类别到指定类别
    &quot;&quot;&quot;</span>
    <span class="hljs-keyword">if</span> cls_name.startswith(<span class="hljs-string">&quot;与乘客交谈&quot;</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;安全驾驶&quot;</span>
    <span class="hljs-keyword">return</span> cls_name
</code></pre>
<h3 id="持续时间计算">持续时间计算</h3>
<p>系统计算每种驾驶行为的持续时间：</p>
<pre><code class="language-python"><span class="hljs-comment"># 计算每个类别的连续帧段</span>
segments = []
segment_start = frames[<span class="hljs-number">0</span>]
prev_frame = frames[<span class="hljs-number">0</span>]

<span class="hljs-keyword">for</span> frame <span class="hljs-keyword">in</span> frames[<span class="hljs-number">1</span>:]:
    <span class="hljs-comment"># 如果与前一帧不连续(差距大于1)，则创建新段</span>
    <span class="hljs-keyword">if</span> frame &gt; prev_frame + <span class="hljs-number">1</span>:
        segments.append((segment_start, prev_frame))
        segment_start = frame
    prev_frame = frame

<span class="hljs-comment"># 添加最后一个段</span>
segments.append((segment_start, prev_frame))

<span class="hljs-comment"># 计算总帧数并转换为时间</span>
duration_seconds = (segment_data[<span class="hljs-string">&#x27;total_frames&#x27;</span>] / fps) <span class="hljs-keyword">if</span> fps &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
</code></pre>
<h2 id="系统优化">系统优化</h2>
<h3 id="内存管理">内存管理</h3>
<p>为避免处理大型视频时内存溢出，系统实现了分批处理策略：</p>
<pre><code class="language-python"><span class="hljs-comment"># 为了减轻内存压力，可以定期处理帧并写入视频</span>
<span class="hljs-keyword">if</span> frame_count % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> frame_count == total_frames - <span class="hljs-number">1</span>:
    <span class="hljs-comment"># 处理并写入视频文件</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, frame_count-<span class="hljs-number">100</span>), frame_count):
        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> frame_results:
            <span class="hljs-comment"># 处理当前帧</span>
            <span class="hljs-comment"># ...</span>
            <span class="hljs-comment"># 写入处理后的帧</span>
            out.write(annotated_frame)
            <span class="hljs-comment"># 从字典中移除已写入的帧，释放内存</span>
            <span class="hljs-keyword">del</span> frame_results[i]
</code></pre>
<h3 id="文件管理">文件管理</h3>
<p>系统会自动清理临时文件，只保留最新的N个文件：</p>
<pre><code class="language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cleanup_folder</span>(<span class="hljs-params">folder_path, max_files=MAX_FILES_PER_FOLDER</span>):
    <span class="hljs-comment"># 获取文件夹中所有文件</span>
    files = [os.path.join(folder_path, f) <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> os.listdir(folder_path) <span class="hljs-keyword">if</span> os.path.isfile(os.path.join(folder_path, f))]
    
    <span class="hljs-comment"># 按文件修改时间排序</span>
    files.sort(key=<span class="hljs-keyword">lambda</span> x: os.path.getmtime(x))
    
    <span class="hljs-comment"># 如果文件数量超过最大值，删除最旧的文件</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) &gt; max_files:
        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> files[:-max_files]:
            os.remove(f)
</code></pre>
<h2 id="部署注意事项">部署注意事项</h2>
<ol>
<li>确保安装所有必要的Python依赖包</li>
<li>模型文件应放置在正确的目录中（./models/car_inside_detect.pt）</li>
<li>如需使用视频格式转换功能，请安装FFmpeg并设置正确的路径</li>
<li>确保上传和输出目录具有正确的读写权限</li>
<li>端口冲突时，系统会自动寻找可用端口</li>
</ol>
<h2 id="结论">结论</h2>
<p>这个驾驶行为检测系统通过整合多种技术，实现了对图片和视频中驾驶行为的智能检测与分析。系统架构清晰，前后端分离，技术路线合理，可靠性高，具有良好的用户体验和扩展性。</p>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>